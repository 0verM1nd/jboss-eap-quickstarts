<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" []>
<chapter id="forge-plugin.dev">
	<title>Developing a Plugin</title>
	<para>
      Part of Forge's architecture is to allow extensions to be created with extreme 
      ease. This is done using the same programming model that you would use for any 
      CDI or Java EE application, and you should quickly recognize the annotation-driven
      patterns and practices applied.
   </para>
   <para>
      A Forge plugin could be as simple as a tool to print files to the console, or
      as complex as deploying an application to a server, 'tweet'ing the status of your
      latest source-code commit, or even sending commands to a home-automation system; 
      the sky is the limit!
   </para>

   <section id="plugin.dev.maven">
      <title>Referencing the Forge APIs</title>
      <para>
         Because Forge is based on Maven, the easiest way to get started quickly writing
         a plugin is to create a new maven Java project. This can be done by hand, or
         using Forge's build in plugin project facet.
      </para>
      <section> 
         <title>Using Forge</title>
         <para>
            In two short steps, you can have a new plugin-project up and running; this
            can be done using Forge itself!
            <orderedlist>
               <listitem>
                  Execute <literal>$ forge</literal> from a command prompt.</listitem>
               <listitem>
                  Create a new project:
                  <programlisting>$ new-project --named {name} --topLevelPackage {com.package} --projectFolder {/directory/path}</programlisting>
               </listitem>
               <listitem>
                  Install the Forge API facet, select the API version you wish to use, and 
                  press ENTER to confirm installation of required facet dependencies:
                  <programlisting>$ install forge.api</programlisting>
               </listitem>
            </orderedlist>
            That's it! Now your project is ready to be compiled and installed in Forge,
            but you may still want to <link linkend="plugin.dev.commands">add some 
            commands</link>.
         </para>
      </section>
      <section>
         <title>With Maven)</title>
         <para>
            If you do not wish to create a new plugin project using Forge itself, you
            will need to manually include the Forge-API dependencies. For purposes of
            simplicity, we have pasted a sample Maven POM file which can
            be used as a starting point for a new plugin:
            
            <tip>
               <literal>'org.jboss.seam.forge : forge-shell-api : {version}'
               </literal> is the only dependency you must include in your project. 
            </tip>
            
            <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                             http://maven.apache.org/xsd/maven-4.0.0.xsd" 
    xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.example.plugin</groupId>
  <artifactId>example</artifactId>
  <version>1.0.0-SNAPSHOT</version>

  <properties>
    <forge.api.version>[1.0.0-SNAPSHOT,)</forge.api.version>
  </properties>
  
  <dependencies>
    <dependency>
      <groupId>org.jboss.seam.forge</groupId>
      <artifactId>forge-shell-api</artifactId>
      <version>${forge.api.version}</version>
    </dependency>
  </dependencies>
  
  <repositories>
    <repository>
      <id>jboss</id>
      <url>https://repository.jboss.org/nexus/content/groups/public/</url>
    </repository>
  </repositories>
  
  <build>
    <plugins>
      <plugin>
        <artifactId>maven-compiler-plugin</artifactId>
        <configuration>
          <source>1.6</source>
          <target>1.6</target>
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>]]></programlisting>
         </para>
      </section>
   </section>

   <section id="plugin.dev.interface">
      <title>Implementing the Plugin interface</title>
      <para>
         Your class must implement the <literal>org.jboss.seam.forge.shell.plugins.Plugin</literal> interface.
         <programlisting>import org.jboss.seam.forge.shell.plugins.Plugin;
         
public class ExamplePlugin implements Plugin {
}</programlisting>
      </para>
   </section>
   
   <section id="plugin.dev.naming">
      <title>Naming your plugin</title>
      Each plugin should be given a name. This is done by adding the 
      <literal>@org.jboss.seam.forge.shell.plugins.Alias</literal> annotation to your plugin class.
      
      By default, if no <literal>@Alias</literal> annotation is found, the 
      lower-case Class name will be used; for instance, our <literal>ExamplePlugin</literal>,
      above, would be executed by typing:
      
      <programlisting>$ exampleplugin </programlisting>
      
      Now we will add a name to our plugin.
      <programlisting>@Alias("example")
public class ExamplePlugin implements Plugin {
   // commands
}</programlisting>
               
      Our named <literal>@Alias("example") ExamplePlugin</literal> would be executed by typing:
      <programlisting>$ example </programlisting>
   </section>
   
   <section id="plugin.dev.classpath">
      <title>Ensure all required classes are on the CLASSPATH</title>
      <para>
         All imports must be available on the <literal>CLASSPATH</literal>. If your Plugin depends 
         on classes that are not provided by Forge, then you must either package
         those classes in the JAR file containing your Plugin (for instance, using the
         maven <ulink url="http://maven.apache.org/plugins/maven-shade-plugin/">shade plugin</ulink>),
         or you must ensure that the required dependencies are also placed on the 
         <literal>CLASSPATH</literal> (typically in the <literal>$FORGE_HOME/lib</literal> folder,)
         otherwise your plugin will *not* be loaded.
      </para>
   </section>
   
   <section id="plugin.dev.installing">
      <title>Make your Plugin available to Forge</title>
      <para>
         After following all of the steps in <link linkend="plugin.dev">this section</link>,
         you should now be ready to install your Plugin into the Forge environment. This
         is accomplished simply by packaging your Plugin in a JAR file with a CDI activator,
         otherwise referred to as a <literal>/META-INF/beans.xml</literal> file.
      </para>
      <tip>
         <para>You must include a /META-INF/beans.xml file in your JAR, or none of the 
         classes in your archive will be discovered; therefore, your Plugin will not be made
         available to Forge.</para>
      </tip>
   </section>
   
   <section id="plugin.dev.commands">
      <title>Add commands to your plugin</title>
      <para>
         Now that you have implemented the <literal>Plugin</literal> interface, it's time
         to add some functionality. This is done by adding "Commands" to your plugin class.
         Commands are plain Java methods in your plugin Class. Plugin methods must be annotated
         as either a <literal>@DefaultCommand</literal>, the method to be invoked if the plugin
         is called by name (with no additional commands), or <literal>@Command(name="...")</literal>,
         in which case a the plugin name and command name must both be used to invoke the method.
      </para>
      <para>
         Commands also accept <literal>@Options</literal> parameters as arguments. These are
         <link linkend="plugins.dev.options">described in detail</link> later in this section.
      </para>
      
      <section id="plugin.dev.commands.default">
         <title>Default commands</title>
         <para>
            Default commands must be annotated with <literal>@DefaultCommand</literal>, and are
            not named; you may still provide help text or command metadata. Each
            plugin may have only one <literal>@DefaultCommand</literal>.
         </para>
         <para>
            The following default command would be executed by executing the plugin by its name:
            
            <programlisting>public class ExamplePlugin implements Plugin {
   @DefaultCommand
   public void exampleDefaultCommand( @Option String opt ) {
      // this method will be invoked, and 'opt' will be passed from the command line
   }
}</programlisting>
            <programlisting>$ exampleplugin some-input</programlisting>
            In this case, the value of '<literal>opt</literal>' will be "some-input".
            <literal>@Options</literal> are <link linkend="plugin.dev.options">described
            in detail</link> later in this section.
        </para>
      </section>
      
      <section id="plugin.dev.commands.named">
         <title>Named commands</title>
         <para>
            Named commands must, to little surprise, be given a name with which they are
            invoked. This is done by placing the <literal>@Command(name="...")</literal> annotation
            on a public Java method in your <literal>Plugin</literal> class.
         </para>
         <para>
            The following command would be executed by executing the plugin by its name,
            followed by the name of the command:
         
            <programlisting>public class ExamplePlugin implements Plugin {
   @Command(name="perform")
   public void exampleCommand( @Option(required=false) String opt, PipeOut out) {
       out.println(">> the command \"perform\" was invoked with the value: " + opt);
   }
}</programlisting>
            <programlisting>$ exampleplugin perform
>> the command "perform" was invoked with the value: null</programlisting>
         </para>
         <para>
            Notice that our command method has a parameter called "<literal>PipeOut</literal>,"
            in addition to our 'opt' parameter. <literal>PipeOut</literal> is a special 
            parameter, which can be placed in any order. It provides access to a
            variety of shell output functions, including enabling color and controlling 
            piping between plugins.
         </para>
         <para>
            Along with <literal>PipeOut</literal>, there is also a 
            <literal>@PipeIn InputStream stream</literal> annotation,
            which is used to inject a piped input stream (output from another
            Plugin's <literal>PipeOut</literal>.) These concepts will be described more in the
            section on <link linkend="plugin.dev.piping">piping</link>, but for now, you
            should just know that <literal>PipeOut</literal> is used to write output
            to the Forge console.
         </para>
      </section>
   </section>
   
   
   
   <section id="plugin.dev.options">
      <title>Understanding command @Options</title>

      <para>
         Once we have a command or two in our Plugin, it's time to give our users some
         control over what it does; to do this, we use <literal>@Option</literal> params;
         options enable users to pass information of various types into our commands.
      </para>
      <para>
         Options can be named, in which case they are set by passing the
         <literal>--name</literal> followed immediately by the value, or if the option
         is a boolean flag, simply passing the flag will signal a `true` value.
         
         Named parameters may be passed into a command in any order, while unnamed 
         parameters must be passed into the command in the order with which
         they were defined.
      </para>
      
      <section id="plugin.dev.options.named">
         <title>--named options</title>
      
         <para>
            As mentioned above, options can be given both a long-name and/or a 
            short-name.  in which case, they would be defined like this:
            
            <programlisting>@Option(name="one", shortName="o")</programlisting>
            
            Short named parameters are called using a single dash '-' followed by
            the letter assigned '-o'; whereas long-named parameters are called using 
            a double dash '--' immediately followed by the name '--one'. )
         </para>
         <para>
            For example, the following command accepts several options, named 'one', 
            and 'two':
            
            <programlisting>public class ExamplePlugin implements Plugin {
   @Command(name="perform")
   public void exampleCommand( 
                  @Option(name="one", shortName="o") String one,
                  @Option(name="two") String two,
                  PipeOut out) {
       out.println(">> option one equals: " + one);
       out.println(">> option two equals: " + two);
   }
}</programlisting>
   
            The above command, when executed, would produce the following output:
         
            <programlisting>$ example-plugin perform --one cat --two dog 
>> option one equals: cat
>> option two equals: dog</programlisting>
         </para>
         <para>
            <tip>
               Named parameters can be called in any order. Notice that we could have also 
               called the command with options 'one' and 'two' in reverse order, or 
               by using their short names. These commands are equivalent:
               <programlisting>$ example-plugin perform --one cat --two dog
$ example-plugin perform --two dog --one cat
$ example-plugin perform --two dog -o cat</programlisting>
            </tip>
         </para>
      </section>
      
      <section id="plugin.dev.options.ordered">
         <title>Ordered options</title>
         <para>
            In addition to <literal>--named</literal> option parameters, as described
            <link linkend="plugin.dev.options.named">above</link>, parameters may also
            be passed on the command line by the order in which they are entered. These
            are called "ordered option parameters", and do not require any parameters
            other than help or description information. 
            
            <programlisting>@Option String value</programlisting>
            
            The order of the options in the method signature controls how values are
            assigned from parsed Forge shell command statements.
         </para>
         <para>
            For example, the following command accepts several options, named 'one', 
            and 'two':
            
            <programlisting>public class ExamplePlugin implements Plugin {
   @Command(name="perform")
   public void exampleCommand( 
                  @Option String one,
                  @Option String two,
                  PipeOut out) {
       out.println(">> first option equals: " + one);
       out.println(">> second option equals: " + two);
   }
}</programlisting>
            The above command, when executed, would produce the following output:
         
            <programlisting>$ example-plugin cat dog 
>> option one equals: cat
>> option two equals: dog</programlisting>
         </para>
      </section>
      
      <section id="plugin.dev.options.combined">
         <title>Combining --named and ordered options</title>
         <para>
            Both <link linkend="plugin.dev.options.named"><literal>--named</literal></link>
            and <link linkend="plugin.dev.options.ordered">ordered</link> option
            parameters can be mixed in the same command; there are some constraints on
            how commands must be typed, but there is a great deal of flexibility as well.
            
            <programlisting>@Option String value,
@Option(name="num") int number</programlisting>
            
            The order of ordered options in the method signature controls how values are
            assigned from the command line shell, whereas the named options have no 
            bearing on the order in which inputs are provided on the command line.
         </para>
         <para>
            For example, the following command accepts several options, named 'one', 
            'two', and several more options that are not named:
            
            <programlisting>public class ExamplePlugin implements Plugin {
   @Command(name="perform")
   public void exampleCommand( 
                  @Option(name="one") String one,
                  @Option(name="two") String two,
                  @Option String three,
                  @Option String four,
                  PipeOut out) {
       out.println(">> first option equals: " + one);
       out.println(">> second option equals: " + two);
       out.println(">> third option equals: " + three);
       out.println(">> fourth option equals: " + four);
   }
}</programlisting>
            The above command, when executed, would produce the following output:
         
            <programlisting>$ example-plugin --one cat --two dog bird lizard  
>> option one equals: cat
>> option two equals: dog 
>> option one equals: bird
>> option two equals: lizard</programlisting>

            However, we could also achieve the same result by re-arranging parameters,
            and as long as the name-value pairs remain together, and the ordered values
            are passed in the correct order, interpretation will remain the same:
            <programlisting>$ example-plugin --two dog bird --one cat lizard  
>> option one equals: cat
>> option two equals: dog 
>> option one equals: bird
>> option two equals: lizard</programlisting>
         </para>
      </section>
      
      <section id="plugin.dev.options.attributes">
         <title>Option attributes and configuration</title>
         <para>
            This table describes all of the available <literal>@Option(...)</literal>
            attributes and their usage.
         
            <informaltable>
               <tgroup cols="4">
                  <colspec colnum="1" colwidth="1*" />
                  <colspec colnum="2" colwidth="1*" />
                  <colspec colnum="3" colwidth="3*" />
                  <colspec colnum="4" colwidth="1*" />
                  <thead>
                     <row>
                        <entry>Attribute</entry>
                        <entry>Type</entry>
                        <entry>Description</entry>
                        <entry>Default</entry>
                     </row>
                  </thead>
                  <tbody>
                     <row>
                        <entry><literal>name</literal></entry>
                        <entry><literal>String</literal></entry>
                        <entry>
                           If specified, defines the 
                           <link linkend="plugin.dev.options.named">--name</link> 
                           with which this option may be passed on the
                           command line. If left blank, this option will be 
                           <link linkend="plugin.dev.options.ordered">ordered</link>
                           (not named,) and will be passed in the order with which
                           it was written in the Method signature.
                           <programlisting>@Option(name="exampleName")</programlisting>
                        </entry>
                        <entry>none</entry>
                     </row>
                     <row>
                        <entry><literal>required</literal></entry>
                        <entry><literal>boolean</literal></entry>
                        <entry>
                           Options may be declared as required when they must be supplied
                           in order for proper command execution. The shell will enforce
                           this requirement by prompting the user for valid input if
                           the option is omitted when the command is executed. 
                           <programlisting>@Option(required="false")</programlisting>
                        </entry>
                        <entry>false</entry>
                     </row>
                     <row>
                        <entry><literal>shortName</literal></entry>
                        <entry><literal>String</literal></entry>
                        <entry>
                           If specified, defines the short name by which this option
                           may be called on the command line. Short names must be one
                           character in length.
                           <link linkend="plugin.dev.options.named">short name</link>
                           with which this option may be passed on the command line.
                        </entry>
                        <entry>none</entry>
                     </row>
                     <row>
                        <entry></entry>
                        <entry></entry>
                        <entry></entry>
                        <entry></entry>
                     </row>
                  </tbody>
               </tgroup>
            </informaltable>
         </para>
      </section>
   </section>
   
   
   <section id="plugin.dev.piping">
      <title>Piping output between plugins</title>
      
      <para>
         Much like a standard UNIX-style shell, the Forge shell supports piping IO between
         executables; however in the case of forge, piping actually occurs between plugins,
         commands, for example:
      </para>
      
      <programlisting>$ cat /home/username/.forge/config | grep automatic 
@/* Automatically generated config file */;</programlisting>

      <para>
         This might look like a typical BASH command, but if you run forge and try it,
         you may be surprised to find that the results are the same as on your system
         command prompt, and in this example, we are demonstrating the pipe: '|'
      </para>      

      <para>
         In order to enable piping in your plugins, you must use one or both of the
         <literal>@PipeIn InputStream stream</literal> or <literal>PipeOut out</literal>
         command arguments. Notice that <literal>PipeOut</literal> is a java type that 
         must be used as a Method parameter, whereas <literal>@PipeIn</literal> is 
         an annotation that must be placed on a Java <literal>InputStream</literal> 
         Method parameter.
      </para>
      <para>
         `<literal>PipeOut out</literal>` - by default - is used to print output to 
         the shell console; however, if the plugin on the left-hand-side is piped to 
         a secondary plugin on the command line, the output will be written to the
         `<literal>@PipeIn InputStream stream</literal>` of the plugin on the 
         right-hand-side:
         
         <programlisting>$ left | right</programlisting>
         
         Or in terms of pipes, this could be thought of as a flow of data from left
         to right:
         
         <programlisting>$ PipeOut out -> @PipeIn InputStream stream</programlisting>
         
         Notice that you can pipe output between any number of plugins as long as each
         uses both a <literal>@PipeIn InputStream</literal> and <literal>PipeOut</literal>:
         
         <programlisting>$ first command | second command | third command</programlisting>
      </para>
      
      <para>
         Take the '<literal>grep</literal>' command itself, for example, which supports
         two methods of invocation: Invocation on one or more <literal>Resource&lt;?&gt;</literal>
         objects, or invocation on a piped <literal>InputStream</literal>.
      </para>
      
      <tip>
         <para>
            If no piping is invoked (e.g: via standalone execution of the plugin), 
            a piped <literal>InputStream</literal> will be null. In addition, piped
            <literal>InputStream</literal>s do not need to be closed; Forge will
            handle cleanup of these streams.
         </para>
      </tip>
      
      <programlisting><![CDATA[@Alias("grep")
@Topic("File & Resources")
@Help("print lines matching a pattern")
public class GrepPlugin implements Plugin
{
   @DefaultCommand
   public void run(
         @PipeIn final InputStream pipeIn,
         @Option(name = "ignore-case", shortName = "i", flagOnly = true) boolean ignoreCase,
         @Option(name = "regexp", shortName = "e") String regExp,
         @Option(description = "PATTERN") String pattern,
         @Option(description = "FILE ...") Resource<?>[] resources, 
         final PipeOut pipeOut
   ) throws IOException
   {
      Pattern matchPattern = /* determine pattern (omitted for space) */;

      if (resources != null) {
      
         /* User passed file(s) on the command line; grep those. */
      
         for (Resource<?> r : resources) {
            InputStream inputStream = r.getResourceInputStream();
            try {
               match(inputStream, matchPattern, pipeOut, ignoreCase);
            }
            finally {
               inputStream.close();
            }
         }
      }
      else if (pipeIn != null) {
      
         /* No files were passed on the command line; check for a 
          * piped InputStream and use that.
          */
      
         match(pipeIn, matchPattern, pipeOut, ignoreCase);
      }
      else {
      
         /* No input was passed to the plugin. */
      
         throw new RuntimeException("Error: arguments required");
      }
   }

   private void match(InputStream instream, Pattern pattern, PipeOut pipeOut, boolean caseInsensitive) throws IOException {
      StringAppender buf = new StringAppender();

      int c;
      while ((c = instream.read()) != -1) { /* Read from the given stream. */
         switch (c) {
         case '\r':
         case '\n':
            String s = caseInsensitive ? buf.toString().toLowerCase() : buf.toString();

            if (pattern.matcher(s).matches()) {
               pipeOut.println(s); /* Write to the output pipe. */
            }
            buf.reset();
            break;
         default:
            buf.append((char) c);
            break;
         }
      }
   }
}]]></programlisting>
      

   </section>
</chapter>
